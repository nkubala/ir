<base href="http://www.cs.utexas.edu/~novak/cs314contents.html">
<HTML>
<!--  cs314contents.html          G. Novak     17 Aug 12    -->
<HEAD>
<TITLE>CS 314: Data Structures: Lecture Notes</TITLE>
</HEAD>

<BODY>
<H2>CS 314: Data Structures: Lecture Notes</H2>
<HR>
<P>
Copyright &#169; 2013 by Gordon S. Novak Jr.
<P>
Permission is granted for individuals to make copies of these notes
for personal use, or for instructors to make copies for classroom use.
<p>
<B>Note:</B> Some of these pages use math symbols.
Microsoft Internet Explorer will not display the math symbols, but
<a href="http://www.mozilla.com">Firefox</a> will.
<P>
<a href="cs314index.html">Index</a><P>
<P>
<A href="cs3141.html">1. CS 314: Data Structures</A><BR>
<A href="cs3142.html">2. Course Topics</A><BR>
<A href="cs3143.html">3. Introduction</A><BR>
<A href="cs3144.html">4. eine kleine LispMusik</A><BR>
<A href="cs3145.html">5. Fibonacci Numbers</A><BR>
<A href="cs3146.html">6. Fibonacci Functions</A><BR>
<A href="cs3147.html">7. Testing Fibonacci</A><BR>
<A href="cs3148.html">8. Rates of Growth</A><BR>
<A href="cs3149.html">9. Exponential Growth</A><BR>
<A href="cs31410.html">10. Goals of the Course</A><BR>
<A href="cs31411.html">11. Big O and Performance</A><BR>
<A href="cs31412.html">12. Big O</A><BR>
<A href="cs31413.html">13. Big O: An Upper Bound</A><BR>
<A href="cs31414.html">14. Rules for Big O</A><BR>
<A href="cs31415.html">15. Classes of Algorithms</A><BR>
<A href="cs31416.html">16. Log n Grows Slowly</A><BR>
<A href="cs31417.html">17. Log n Is Almost the Same as 1</A><BR>
<A href="cs31418.html">18. Powers of 10: SI Prefixes</A><BR>
<A href="cs31419.html">19. A Scientist Should Be Careful, Skeptical</A><BR>
<A href="cs31420.html">20. Finding Big O: Log-log Graph</A><BR>
<A href="cs31421.html">21. Log-log Example</A><BR>
<A href="cs31422.html">22. Finding Big O: Semi-Log Graph</A><BR>
<A href="cs31423.html">23. Big O from Timing Ratio</A><BR>
<A href="cs31424.html">24. Computation Model</A><BR>
<A href="cs31425.html">25. Big O from Code</A><BR>
<A href="cs31426.html">26. Big O of Loops</A><BR>
<A href="cs31427.html">27. Beware the Bermuda Triangle</A><BR>
<A href="cs31428.html">28. Big O for Arrays</A><BR>
<A href="cs31429.html">29. Average Case vs. Worst Case</A><BR>
<A href="cs31430.html">30. Familiarity with Big O</A><BR>
<A href="cs31431.html">31. Pointer / Reference</A><BR>
<A href="cs31432.html">32. Boxed Number</A><BR>
<A href="cs31433.html">33. References and <TT>==</TT> </A><BR>
<A href="cs31434.html">34. <TT>==</TT> vs. <TT>.equals()</TT> </A><BR>
<A href="cs31435.html">35. Linked List</A><BR>
<A href="cs31436.html">36. Constructing a Linked List</A><BR>
<A href="cs31437.html">37. Access to Parts of a List</A><BR>
<A href="cs31438.html">38. List Access Functions </A><BR>
<A href="cs31439.html">39. Iterative Processing of List</A><BR>
<A href="cs31440.html">40. Iterative List Design Pattern</A><BR>
<A href="cs31441.html">41. Recursion</A><BR>
<A href="cs31442.html">42. Designing Recursive Functions</A><BR>
<A href="cs31443.html">43. Design Pattern for Recursive Functions</A><BR>
<A href="cs31444.html">44. Recursive Processing of List</A><BR>
<A href="cs31445.html">45. Recursive List Design Pattern</A><BR>
<A href="cs31446.html">46. Tail Recursive Processing of List</A><BR>
<A href="cs31447.html">47. Tail Recursive List Design Pattern</A><BR>
<A href="cs31448.html">48. Constructive Linked List: Reverse</A><BR>
<A href="cs31449.html">49. Tail Recursive Reverse</A><BR>
<A href="cs31450.html">50. Tail Recursive Reverse in Java</A><BR>
<A href="cs31451.html">51. Copying a List</A><BR>
<A href="cs31452.html">52. Append</A><BR>
<A href="cs31453.html">53. Iterative Append</A><BR>
<A href="cs31454.html">54. Destructive Linked List Functions</A><BR>
<A href="cs31455.html">55. Nconc</A><BR>
<A href="cs31456.html">56. Nreverse</A><BR>
<A href="cs31457.html">57. Set as Linked List</A><BR>
<A href="cs31458.html">58. Intersection</A><BR>
<A href="cs31459.html">59. Tail-Recursive Intersection</A><BR>
<A href="cs31460.html">60. Tail-Recursive Intersection in Java</A><BR>
<A href="cs31461.html">61. Union and Set Difference</A><BR>
<A href="cs31462.html">62. Circularly Linked List</A><BR>
<A href="cs31463.html">63. Merge</A><BR>
<A href="cs31464.html">64. Constructive Merge</A><BR>
<A href="cs31465.html">65. Tail Recursive Merge</A><BR>
<A href="cs31466.html">66. Tail Recursive Merge in Java</A><BR>
<A href="cs31467.html">67. Destructive Merge Function</A><BR>
<A href="cs31468.html">68. Iterative Destructive Merge</A><BR>
<A href="cs31469.html">69. Java Iterative Destructive Merge</A><BR>
<A href="cs31470.html">70. Divide and Conquer</A><BR>
<A href="cs31471.html">71. Dividing a List</A><BR>
<A href="cs31472.html">72. Sorting by Merge</A><BR>
<A href="cs31473.html">73. Tracing Sort and Merge</A><BR>
<A href="cs31474.html">74. On Not Dropping the Ball</A><BR>
<A href="cs31475.html">75. Divide and Conquer Design Pattern</A><BR>
<A href="cs31476.html">76. Intersection by Merge</A><BR>
<A href="cs31477.html">77. Sort, then Merge</A><BR>
<A href="cs31478.html">78. Association List</A><BR>
<A href="cs31479.html">79. Stack using Linked List</A><BR>
<A href="cs31480.html">80. Sentinel Node</A><BR>
<A href="cs31481.html">81. Other Uses of Linked Lists</A><BR>
<A href="cs31482.html">82. Arrays</A><BR>
<A href="cs31483.html">83. Stack using Array</A><BR>
<A href="cs31484.html">84. Uses of Stacks</A><BR>
<A href="cs31485.html">85. Recursion and Runtime Stack</A><BR>
<A href="cs31486.html">86. Recursive Function Execution</A><BR>
<A href="cs31487.html">87. Recursive Execution ...</A><BR>
<A href="cs31488.html">88. Recursive Length Function Execution</A><BR>
<A href="cs31489.html">89. Balancing Parentheses</A><BR>
<A href="cs31490.html">90. Balance Test Using Stack</A><BR>
<A href="cs31491.html">91. Linked List Stack</A><BR>
<A href="cs31492.html">92. Tree Traversal and Stack</A><BR>
<A href="cs31493.html">93. XML</A><BR>
<A href="cs31494.html">94. Queues</A><BR>
<A href="cs31495.html">95. Two Pointer Queue using Linked List</A><BR>
<A href="cs31496.html">96. Circular Queue using Array</A><BR>
<A href="cs31497.html">97. Circular Queue Code</A><BR>
<A href="cs31498.html">98. Java Collection API</A><BR>
<A href="cs31499.html">99. Java Collections Iteration</A><BR>
<A href="cs314100.html">100. Filter Pattern</A><BR>
<A href="cs314101.html">101. Using Library Packages</A><BR>
<A href="cs314102.html">102. Java List Interface</A><BR>
<A href="cs314103.html">103. ArrayList</A><BR>
<A href="cs314104.html">104. LinkedList</A><BR>
<A href="cs314105.html">105. ListIterator</A><BR>
<A href="cs314106.html">106. Comparing ArrayList and LinkedList</A><BR>
<A href="cs314107.html">107. Trees</A><BR>
<A href="cs314108.html">108. Arithmetic Expressions as Trees</A><BR>
<A href="cs314109.html">109. Computer Programs as Trees</A><BR>
<A href="cs314110.html">110. English Sentences as Trees</A><BR>
<A href="cs314111.html">111. File Systems as Trees</A><BR>
<A href="cs314112.html">112. Phylogenetic Trees</A><BR>
<A href="cs314113.html">113. Taxonomies as Trees</A><BR>
<A href="cs314114.html">114. Ontologies as Trees</A><BR>
<A href="cs314115.html">115. Organizations as Trees</A><BR>
<A href="cs314116.html">116. Nerves</A><BR>
<A href="cs314117.html">117. Representations of Trees</A><BR>
<A href="cs314118.html">118. Binary Tree</A><BR>
<A href="cs314119.html">119. First-Child / Next-Sibling Tree</A><BR>
<A href="cs314120.html">120. First-Child / Next-Sibling Example</A><BR>
<A href="cs314121.html">121. Linked List Tree</A><BR>
<A href="cs314122.html">122. Implicit Tree</A><BR>
<A href="cs314123.html">123. Binary Search Tree (BST)</A><BR>
<A href="cs314124.html">124. Binary Tree Search</A><BR>
<A href="cs314125.html">125. Binary Search of Array</A><BR>
<A href="cs314126.html">126. Binary Tree Array Search</A><BR>
<A href="cs314127.html">127. Binary Array Search Example</A><BR>
<A href="cs314128.html">128. Binary Tree Recursion</A><BR>
<A href="cs314129.html">129. Binary Tree Recursion</A><BR>
<A href="cs314130.html">130. Design Pattern: Binary Tree Recursion</A><BR>
<A href="cs314131.html">131. Binary Tree Recursion Pattern in Java</A><BR>
<A href="cs314132.html">132. Design Pattern: Binary Tree Recursion</A><BR>
<A href="cs314133.html">133. Searching Directories for a File</A><BR>
<A href="cs314134.html">134. Findpath Example</A><BR>
<A href="cs314135.html">135. Findpath Representation</A><BR>
<A href="cs314136.html">136. Java Version of Findpath</A><BR>
<A href="cs314137.html">137. Lisp Version of Findpath</A><BR>
<A href="cs314138.html">138. Searching Directories Example</A><BR>
<A href="cs314139.html">139. Searching Directories Example ...</A><BR>
<A href="cs314140.html">140. Big O for Trees</A><BR>
<A href="cs314141.html">141. Depth First Search</A><BR>
<A href="cs314142.html">142. Depth First Search Order</A><BR>
<A href="cs314143.html">143. Robot Mouse in Maze</A><BR>
<A href="cs314144.html">144. Robot Mouse in Java</A><BR>
<A href="cs314145.html">145. Robot Mouse Program</A><BR>
<A href="cs314146.html">146. Robot Mouse Example</A><BR>
<A href="cs314147.html">147. Tracing the Robot Mouse</A><BR>
<A href="cs314148.html">148. Tracing the Robot Mouse ...</A><BR>
<A href="cs314149.html">149. Tree Traversal</A><BR>
<A href="cs314150.html">150. Preorder</A><BR>
<A href="cs314151.html">151. Preorder Example</A><BR>
<A href="cs314152.html">152. Preorder Example in Java</A><BR>
<A href="cs314153.html">153. Inorder</A><BR>
<A href="cs314154.html">154. Inorder Printing of Binary Tree</A><BR>
<A href="cs314155.html">155. Flattening Binary Tree</A><BR>
<A href="cs314156.html">156. Tracing Flattening Binary Tree</A><BR>
<A href="cs314157.html">157. Flattening Binary Tree in Java</A><BR>
<A href="cs314158.html">158. Postorder</A><BR>
<A href="cs314159.html">159. Balanced Binary Trees</A><BR>
<A href="cs314160.html">160. AVL Tree</A><BR>
<A href="cs314161.html">161. Tree Rotation</A><BR>
<A href="cs314162.html">162. B-Tree</A><BR>
<A href="cs314163.html">163. B-Tree Implementation</A><BR>
<A href="cs314164.html">164. Advantages of B-Trees</A><BR>
<A href="cs314165.html">165. Quadtree</A><BR>
<A href="cs314166.html">166. Image Quadtree</A><BR>
<A href="cs314167.html">167. Intersection of Quadtrees</A><BR>
<A href="cs314168.html">168. Aggregate Data in Quadtrees</A><BR>
<A href="cs314169.html">169. Uses of Quadtrees</A><BR>
<A href="cs314170.html">170. Be Extreme!</A><BR>
<A href="cs314171.html">171. Sparse Arrays</A><BR>
<A href="cs314172.html">172. Pattern Matching Overview</A><BR>
<A href="cs314173.html">173. Copy Tree and Substitute</A><BR>
<A href="cs314174.html">174. Copy Tree and Substitute in Java</A><BR>
<A href="cs314175.html">175. Binding Lists</A><BR>
<A href="cs314176.html">176. Multiple Substitutions</A><BR>
<A href="cs314177.html">177. Sublis in Java</A><BR>
<A href="cs314178.html">178. Instantiating Design Patterns</A><BR>
<A href="cs314179.html">179. Tree Equality</A><BR>
<A href="cs314180.html">180. Tree Equality in Java</A><BR>
<A href="cs314181.html">181. Tracing Equal</A><BR>
<A href="cs314182.html">182. Design Pattern: Nested Tree Recursion</A><BR>
<A href="cs314183.html">183. Tracing Nested Tree Recursion</A><BR>
<A href="cs314184.html">184. Pattern Matching</A><BR>
<A href="cs314185.html">185. Specifications of Match</A><BR>
<A href="cs314186.html">186. Match Function</A><BR>
<A href="cs314187.html">187. Match Function in Java</A><BR>
<A href="cs314188.html">188. Transformation by Patterns</A><BR>
<A href="cs314189.html">189. Transformation Patterns</A><BR>
<A href="cs314190.html">190. Program Transformation using Lisp</A><BR>
<A href="cs314191.html">191. Programs and Trees</A><BR>
<A href="cs314192.html">192. Set API in Java</A><BR>
<A href="cs314193.html">193. Map API in Java</A><BR>
<A href="cs314194.html">194. Iteration over a <TT>Map</TT></A><BR>
<A href="cs314195.html">195. Array as a <TT>Map</TT></A><BR>
<A href="cs314196.html">196. Avoid Repeated Code </A><BR>
<A href="cs314197.html">197. Initializing Array </A><BR>
<A href="cs314198.html">198. Key of a <TT>Map</TT></A><BR>
<A href="cs314199.html">199. Hashing</A><BR>
<A href="cs314200.html">200. Hash Function</A><BR>
<A href="cs314201.html">201. Java <TT>.hashCode()</TT></A><BR>
<A href="cs314202.html">202. Exclusive OR</A><BR>
<A href="cs314203.html">203. Uses of Exclusive OR</A><BR>
<A href="cs314204.html">204. Hash Function for Strings</A><BR>
<A href="cs314205.html">205. Hash Function for Application Types</A><BR>
<A href="cs314206.html">206. Collisions</A><BR>
<A href="cs314207.html">207. Hashing with Buckets</A><BR>
<A href="cs314208.html">208. Hashing with Buckets: Code</A><BR>
<A href="cs314209.html">209. Rehashing</A><BR>
<A href="cs314210.html">210. Hash Tables in Java</A><BR>
<A href="cs314211.html">211. Extendible Hashing</A><BR>
<A href="cs314212.html">212. Uses of Hashing</A><BR>
<A href="cs314213.html">213. Randomization</A><BR>
<A href="cs314214.html">214. Priority Queue</A><BR>
<A href="cs314215.html">215. Priority Queue with Array or Binary Tree</A><BR>
<A href="cs314216.html">216. Binary Heap</A><BR>
<A href="cs314217.html">217. Mapping to Array</A><BR>
<A href="cs314218.html">218. Insertion into Heap</A><BR>
<A href="cs314219.html">219. Removal from Heap</A><BR>
<A href="cs314220.html">220. Uses of Priority Queues</A><BR>
<A href="cs314221.html">221. <TT>PriorityQueue</TT> in Java</A><BR>
<A href="cs314222.html">222. Example Discrete Event Simulation</A><BR>
<A href="cs314223.html">223. Sorting</A><BR>
<A href="cs314224.html">224. Comparison in Java</A><BR>
<A href="cs314225.html">225. Insertion Sort</A><BR>
<A href="cs314226.html">226. Insertion Sort Performance</A><BR>
<A href="cs314227.html">227. Heapsort</A><BR>
<A href="cs314228.html">228. Merge Sort</A><BR>
<A href="cs314229.html">229. Merge Sort Performance</A><BR>
<A href="cs314230.html">230. Memory Hierarchy and Locality</A><BR>
<A href="cs314231.html">231. Does Array Index Order Matter?</A><BR>
<A href="cs314232.html">232. Array Storage and Indexing</A><BR>
<A href="cs314233.html">233. Quicksort</A><BR>
<A href="cs314234.html">234. Quicksort Code</A><BR>
<A href="cs314235.html">235. Partitioning</A><BR>
<A href="cs314236.html">236. Quicksort Example</A><BR>
<A href="cs314237.html">237. Quicksort Performance</A><BR>
<A href="cs314238.html">238. Radix Sort</A><BR>
<A href="cs314239.html">239. Radix Sort Example</A><BR>
<A href="cs314240.html">240. Sorting in Java Library</A><BR>
<A href="cs314241.html">241. Graphs</A><BR>
<A href="cs314242.html">242. Examples of Graphs</A><BR>
<A href="cs314243.html">243. Directed Acyclic Graph</A><BR>
<A href="cs314244.html">244. Graph Representations</A><BR>
<A href="cs314245.html">245. Adjacency List</A><BR>
<A href="cs314246.html">246. Adjacency Matrix</A><BR>
<A href="cs314247.html">247. Implicit Graphs</A><BR>
<A href="cs314248.html">248. Topological Sort</A><BR>
<A href="cs314249.html">249. Uses of Topological Sort</A><BR>
<A href="cs314250.html">250. PERT Chart</A><BR>
<A href="cs314251.html">251. PERT Chart: Calculating Times</A><BR>
<A href="cs314252.html">252. Shortest Path Problem</A><BR>
<A href="cs314253.html">253. Dijkstra's Algorithm</A><BR>
<A href="cs314254.html">254. Dijkstra's Algorithm</A><BR>
<A href="cs314255.html">255. Dijkstra's Algorithm Example</A><BR>
<A href="cs314256.html">256. Minimum Spanning Tree</A><BR>
<A href="cs314257.html">257. Prim's Algorithm</A><BR>
<A href="cs314258.html">258. Prim's Algorithm</A><BR>
<A href="cs314259.html">259. Prim's Algorithm Example</A><BR>
<A href="cs314260.html">260. Directed Search</A><BR>
<A href="cs314261.html">261. Hill Climbing</A><BR>
<A href="cs314262.html">262. Heuristic Search: A*</A><BR>
<A href="cs314263.html">263. A* Algorithm</A><BR>
<A href="cs314264.html">264. Ordered Search for Route Finding</A><BR>
<A href="cs314265.html">265. Effect of Heuristic Function</A><BR>
<A href="cs314266.html">266. Heuristic Search Handles Local Maxima</A><BR>
<A href="cs314267.html">267. A* Algorithm Example</A><BR>
<A href="cs314268.html">268. Graph Search Algorithm Summary</A><BR>
<A href="cs314269.html">269. Mapping</A><BR>
<A href="cs314270.html">270. Implementation of Mapping</A><BR>
<A href="cs314271.html">271. Functional Programming</A><BR>
<A href="cs314272.html">272. Associative and Commutative</A><BR>
<A href="cs314273.html">273. Computation as Simulation</A><BR>
<A href="cs314274.html">274. Mapping in Lisp</A><BR>
<A href="cs314275.html">275. Mapcan</A><BR>
<A href="cs314276.html">276. Input Filtering and Mapping</A><BR>
<A href="cs314277.html">277. Reduce in Lisp</A><BR>
<A href="cs314278.html">278. Combining Map and Reduce</A><BR>
<A href="cs314279.html">279. MapReduce and Massive Data</A><BR>
<A href="cs314280.html">280. Distributed Programming is Hard!</A><BR>
<A href="cs314281.html">281. What MapReduce Does for Us</A><BR>
<A href="cs314282.html">282. Map Sort Reduce</A><BR>
<A href="cs314283.html">283. Simplified MapReduce</A><BR>
<A href="cs314284.html">284. Mapreduce in Lisp</A><BR>
<A href="cs314285.html">285. Simple MapReduce Example</A><BR>
<A href="cs314286.html">286. MapReduce Example</A><BR>
<A href="cs314287.html">287. Hamburger Example</A><BR>
<A href="cs314288.html">288. PageRank</A><BR>
<A href="cs314289.html">289. PageRank Example</A><BR>
<A href="cs314290.html">290. Running PageRank Example</A><BR>
<A href="cs314291.html">291. Advanced Performance</A><BR>
<A href="cs314292.html">292. Performance Techniques in MapReduce</A><BR>
<A href="cs314293.html">293. Buffering</A><BR>
<A href="cs314294.html">294. Load Balancing</A><BR>
<A href="cs314295.html">295. Algorithm Failure</A><BR>
<A href="cs314296.html">296. Atomic Commit</A><BR>
<HR>
<a href="cs314.html">CS 314</a><BR>
</BODY>
</HTML>
